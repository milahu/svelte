import * as fs from 'fs';
import * as path from 'path';
import * as assert from 'assert';
import { loadConfig, svelte } from '../helpers';
// keep source-map at version 0.7.x
// https://github.com/mozilla/source-map/issues/400
import { SourceMapConsumer } from 'source-map';
import { getLocator } from 'locate-character';
import { encode as encode_mappings, decode as decode_mappings } from 'sourcemap-codec';

describe("sourcemaps", () => {
	fs.readdirSync(`${__dirname}/samples`).forEach(dir => {
		if (dir[0] === '.') return;

		const config = loadConfig(`${__dirname}/samples/${dir}/_config.js`);

		// add .solo to a sample directory name to only run that test
		const solo = config.solo || /\.solo/.test(dir);
		const skip = config.skip || /\.skip/.test(dir);

		if (solo && process.env.CI) {
			throw new Error('Forgot to remove `solo: true` from test');
		}

		(solo ? it.only : skip ? it.skip : it)(dir, async () => {
			const { test } = require(`./samples/${dir}/test.js`);
			const inputFile = path.resolve(`${__dirname}/samples/${dir}/input.svelte`);
			const outputName = '_actual';
			const outputBase = path.resolve(`${__dirname}/samples/${dir}/${outputName}`);

			const input = {};
			input.code = fs.readFileSync(inputFile, "utf-8");
			input.locate = getLocator(input.code);

			let preprocessed;
			try {
				preprocessed = await svelte.preprocess(
					input.code,
					config.preprocess, {
					filename: "input.svelte"
				});
			} catch (error) {
				preprocessed = { error };
				// run test without js, css
				return test({ assert, input, preprocessed });
			}

			// preprocessed.map.mappings should be decoded
			// to avoid unnecessary encode + decode steps
			if (preprocessed.map) {
				assert.equal(typeof preprocessed.map.mappings, 'object', 'preprocessed.map.mappings should be decoded');
				assert.equal(Array.isArray(preprocessed.map.mappings), true, 'preprocessed.map.mappings should be decoded');
			}

			const { js, css } = svelte.compile(
				preprocessed.code, {
				filename: "input.svelte",
				sourcemap: preprocessed.map,
				// filenames for sourcemaps
				outputFilename: `${outputName}.js`,
				cssOutputFilename: `${outputName}.css`,
			});

			js.code = js.code.replace(
				/generated by Svelte v\d+\.\d+\.\d+/,
				match => match.replace(/\d/g, "x")
			);

			fs.writeFileSync(`${outputBase}.svelte`, preprocessed.code);
			if (preprocessed.map) {
				fs.writeFileSync(
					`${outputBase}.svelte.map`,
					// TODO encode mappings for output - svelte.preprocess returns decoded mappings
					JSON.stringify(preprocessed.map, null, 2)
				);
			}
			fs.writeFileSync(
				`${outputBase}.js`,
				`${js.code}\n//# sourceMappingURL=${outputName}.js.map`
			);
			fs.writeFileSync(
				`${outputBase}.js.map`,
				JSON.stringify(js.map, 0, 2)
			);
			if (css.code) {
				fs.writeFileSync(
					`${outputBase}.css`,
					`${css.code}\n/*# sourceMappingURL=${outputName}.css.map */`
				);
				fs.writeFileSync(
					`${outputBase}.css.map`,
					JSON.stringify(css.map, 0, 2)
				);
			}

			assert.deepEqual(
				js.map.sources.slice().sort(),
				(config.js_map_sources || ["input.svelte"]).sort()
			);
			if (css.map) {
				assert.deepEqual(
					css.map.sources.slice().sort(),
					(config.css_map_sources || ["input.svelte"]).sort()
				);
			};

			// stupid workaround (unnecessary encode + decode steps)
			// TODO find a SourceMapConsumer who also consumes decoded mappings
			if (preprocessed.map) {
				preprocessed.map.mappings = encode_mappings(preprocessed.map.mappings);
			}

			// use locate_1 with mapConsumer:
			// lines are one-based, columns are zero-based

			preprocessed.mapConsumer = preprocessed.map && await new SourceMapConsumer(preprocessed.map);
			preprocessed.locate = getLocator(preprocessed.code);
			preprocessed.locate_1 = getLocator(preprocessed.code, { offsetLine: 1 });

			js.mapConsumer = js.map && await new SourceMapConsumer(js.map);
			js.locate = getLocator(js.code);
			js.locate_1 = getLocator(js.code, { offsetLine: 1 });

			css.mapConsumer = css.map && await new SourceMapConsumer(css.map);
			css.locate = getLocator(css.code || '');
			css.locate_1 = getLocator(css.code || '', { offsetLine: 1 });

			test({ assert, input, preprocessed, js, css });
		});
	});
});
